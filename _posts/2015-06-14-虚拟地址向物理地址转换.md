---
layout: post
tags: 	操作系统 内存管理
date:	2015-06-14 20:14 
title:	虚拟地址向物理地址的转换
published: true
---
目录：

	1 总体概述
	2 页表项结构
	3 缺页异常
	4 不同的层次结构
	5 补充

### 1 总体概述
![va_pa.png]({{site.imageurl}}/va_pa.png =300*200)
　　首先CPU从指令中获取到虚拟地址，然后该虚拟地址交给MMU，从中查找页表，如果页表项存在，则可以根据页表项找到物理地址，从而根据指令类型和页表项位标识读写cache/mem，如果页表项不存在就会产生缺页异常。

### 2 页表项结构
![page_table.png]({{site.imageurl}}/page_table.png)
　　可以看到虚拟地址包括：虚拟叶号（VPN）和偏移地址
　　而虚拟叶号中包括：叶项有效位，访问控制位（RW）和物理帧号（PFN）
　　重新划分后可以得到物理地址：物理帧号和偏移地址

### 3 缺页异常
![page_fault.png]({{site.imageurl}}/page_fault.png)
　　MMU根据虚拟地址查找页表项，如果对应页表项无效（有效位标记）则就会产生缺页异常，此时MMU会从内存匿名池中获取一帧内存，更新页表项信息，然后从Disk中搬移数据填充。如果内存已全部使用完，则需要根据替换策略替换出一帧内存，并跟新页表项。　

### 4 不同的层次结构
![virtual_physical_cache.png]({{site.imageurl}}/virtual_physical_cache.png)
　　物理cache：因为采用TLB管理，有很好的替换策略，对于命中率不高、需要频繁切换的应用效率比较高。
　　虚拟cache：cache命中率比较高（单线程优）时采用虚拟cache，因为地址翻译延迟很高，不能充分发挥cache的优势。
　　虚拟-物理cache：减少了关键路径，少见。

### 5 补充
　　OS产生之前我们基本采用手动分配内存，而对于未知的应用又没法定义应用所使用的内存的范围，OS之后的虚存可以对内存进行妥善的管理，使通用性大大增强，并可以保证多个任务顺利安全的进行。（域的管理用的比较少）
　　对于每个应用都存在0～3G的用户空间内存，应用可以采用连续的某一段虚拟地址进行访存，其中内存的分配：代码段+常量数据段+全局数据段，按顺序一层层生长，堆数据也同样往上长，栈数据往下压。
　　随应用进程产生虚拟地址从匿名池（空闲内存管理池）中申请物理内存与虚拟地址关联，应用进程关闭，物理内存得到释放（取消关联）。
